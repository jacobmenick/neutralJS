<!DOCTPYE html>
<html>
	<head>
		<meta charset="utf-8">
		<link type="text/css" rel="stylesheet" href="css/neutral.css">
		<link href='http://fonts.googleapis.com/css?family=Josefin+Slab' rel='stylesheet' type='text/css'>   
		<title> Neutral Models </title>
		<script src="js/d3/d3.v3.js"></script>
	</head>
	<body>
		<h1>Neutral Multiparental Trait Genealogy</h1>
		<div id="controlBox">
			<div id="controls">

				<!-- csv download form -->

				<p id ="buttonz">
					<label for="ppe">
						Parents per Entity: <span id="ppe-value">...</span>
					</label>
					<input type="range" min="1" max="20" id="ppe" value="1">
					<label for="tpe">
						Traits per Entity: <span id="tpe-value">…</span>
					</label>
					<input type="range" min="1" max="20" id="tpe" value="1">
					<label for="tds">
						Trait Pool Size: <span id="tds-value">…</span>
					</label>
					<input type="range" min="1" max="10000" id="tds" value="100">
					<label for="ng">
						Num Generations: <span id="ng-value">…</span>
					</label>
					<input type="range" min="1" max="100" id="ng" value="50">
					<label for="pg">
						Entities per Generation: <span id="pg-value">…</span>
					</label>
					<input type="range" min="1" max="40" id="pg" value="20">
					<button type="button" id ="citeToggle">Toggle Parent links</button>
					<button type="button" id ="shareToggle">Toggle Trait Share links</button>
					<button type="button" id="parCsvDownload"> Download Parentage CSV  </button>
					<button type="button" id="trCsvDownload"> Download Trait CSV </button>
				</p>
			</div>
		</div>
		<div id="stats"></div>
		<div id="visContainer">
		<div id="price"></div>
		<div id="vis"></div>
		<script src="js/flatNeutral.js"></script>
		<script src="js/colorbrewer.v1.min.js"></script>
		<script>

			// general d3 settings.
			var margin = {top: 20, right: 20, bottom: 20, left: 20};
			var width = 1500 - margin.left - margin.right;
			var height = 4000 - margin.top - margin.bottom;
			var svg = d3.select("#vis").append("svg")
			  .attr("width", width + margin.left + margin.right)
			  .attr("height", height + margin.top + margin.bottom);

			d3.select("#stats").append("h2")
			  .text("Summary Statistics");

			var statCanvas = d3.select("#stats").append("svg")
			  .attr("width", width + margin.left + margin.right)
			  .attr("height", 100);
			
			// display settings
			var showCites = false;
			var showShares = true;

			// neutralModel settings. 
			var numGens = 100;
			var entitiesPerGen = 20;
			var parentsPerEntity = 1;
			var traitsPerEntity = 1;
			var traitDictSize = 100;

			// scales
			var xScale = d3.scale.ordinal()
			    .domain(rangeFunc(entitiesPerGen))
			    .rangeRoundBands([300, width], 2);

			var yScale = d3.scale.ordinal()
			    .domain(rangeFunc(numGens))
			    .rangeRoundBands([0, height], 1);

			var colorScale = d3.scale.ordinal()
			    .domain(rangeFunc(traitDictSize))
			    .range(colorbrewer.RdBu[4]);

			var radScale = d3.scale.pow().exponent(.5)
			  .domain([0, 20])
			  .range([2,12]);

			// create Neutral Model.
			var nm = new NeutralModel(numGens, entitiesPerGen, parentsPerEntity, traitsPerEntity, traitDictSize);
			nm.createModel();

			

			// render the model. 
			render(nm, false, showCites, showShares);

			// slider init values;
			d3.select("#ppe-value").text(parentsPerEntity);
			d3.select("#tpe-value").text(traitsPerEntity);
			d3.select("#tds-value").text(traitDictSize);
      d3.select("#ng-value").text(numGens);
			d3.select("#pg-value").text(entitiesPerGen);

			// generate svg path objects given source and destination entities. 
			// this one is a curve.
			function generateSVGPath(source, dest) {
					pathTemp = "M"+xScale(source.genIndex)+","+yScale(source.generation);
					if (source.genIndex > dest.genIndex) {
							// control point is to the left. 
							if (source.genIndex == dest.genIndex) {
									pathTemp += (" Q" + (xScale(source.genIndex)) +","
															 +yScale(source.generation));
							} else {
									pathTemp += (" Q" + (xScale(source.genIndex)) +","
															 +yScale(source.generation));
							}
					} else {
							// control point is to the right. 
							pathTemp += (" Q" + (xScale(source.genIndex + 1)) + "," + yScale(source.generation - 1));
					} 
					pathTemp += " "+ xScale(dest.genIndex) +","+ yScale(dest.generation);
					return pathTemp;
			}

			// this one is a line.
			function generateSVGLine(source, dest) {
					pathTemp = "M"+xScale(source.genIndex)+","+yScale(source.generation);
					pathTemp += " L"+xScale(dest.genIndex)+","+yScale(dest.generation);
					return pathTemp;
			}

			// This is the big function.
			function render(newM, shareArr, showCites, showShares) {
					// Are we provided with a specific share array? 
					if (!shareArr) {
							var sharez = newM.getShareArray();;
					} else {
							var sharez = shareArr;
					}

					// remove existing elements. 
					d3.selectAll(".entity").remove();
					d3.selectAll(".citeLink").remove();
					d3.selectAll(".shareLink").remove();
					d3.selectAll(".summaryText").remove();
					d3.select("#selecta").remove();

					// bind new data to nodes
					var nodes = svg.selectAll(".entity").data(newM.population)
					nodes.enter().append("circle")
							.attr("class", "entity")
							.attr("cx", function(d) {
									return xScale(d.genIndex); 
							})
							.attr("cy", function(d) {
									return yScale(d.generation);
							})
					    .attr("r", function(d) {
									return radScale(d.children.length);
							})
					    .on("mouseover", function(d) {
									return entityTip(d);
							})
					    .on("mouseout", function() {
									d3.selectAll(".entityTip").remove();
							});

					// Display citation links if told to do so. 
					if (showCites) {
							var cites = svg.selectAll(".citeLink").data(newM.getCiteArray());
							cites.enter().append("path")
									.attr("class", "citeLink")
							    .attr("stroke", "black") 
									.attr("d", function(d) {
											return generateSVGLine(d.child, d.parent)
									});
					}

					// Display share links if told to do so. 
					if (showShares) {
							var links = svg.selectAll(".shareLink").data(sharez);
							links.enter().append("path")
									.attr("class", "shareLink")
									.attr("stroke", function(d) {
											return colorScale(d.share.trait);
									})
									.attr("d", function(d) {
											return generateSVGLine(d.child, d.share.parent);
									})
							    .on("mouseover", function(d) {
											return shareTip(d);
									})
							    .on("mouseout", function() {
											d3.selectAll(".shareTip").remove();
									})
					}

					// Append summary stat. 
					statCanvas.append("text")
							.attr("id", "avgTraitStat")
							.attr("class", "summarytext")
							.attr("x", 80)
							.attr("y", 60)
							.text(function() {
									return "Avg. Num. Traits shared w/ Parents: "+ newM.avgNumTraitShares();
							});
					
					// Add label for trait filter dropdown
			                // d3.select("#buttonz").append("label").text('Filter by trait: ');
					var select = d3.select("#buttonz").append("select").attr("id", "selecta");
					var options = select.selectAll(".option").data(newM.whichTraitsShared);

					// add dropdown for seeing particular traits. 
					options.enter().append("option")
							.attr("class", "option")
					    .attr("value", function(d) { return d; })
							.text(function(d) { return d; });

					// Update 
					d3.select("#selecta").on("change", function() {
							updateTraitFilter(nm, newM.whichTraitsShared[this.selectedIndex]);
					});



			

					
			} // end render

			
			// Update funcs. 
			function updateParentsPer(nm, newPPE) {
					nm.clear();
					nm.parentsPerEntity = newPPE;
					nm.createModel();
					render(nm, false, showCites, showShares);
					svg.select("#avgTraitStat").text(function() {
							return "Avg. Num. Traits shared w/ Parents: "+nm.avgNumTraitShares();
					})
					return nm;
			}

			function updateTraitsPer(nm, newTPE) {
					nm.clear();
					nm.traitsPerEntity = newTPE;
					nm.createModel();
					render(nm, false, showCites, showShares);
					d3.select("#avgTraitStat").text(function() {
							return "Avg. Num. Traits shared w/ Parents: "+nm.avgNumTraitShares();
					})
					return nm;
			}

			function updateTraitDictSize(nm, newTDS) {
					nm.clear();
					nm.traitDictSize = newTDS;
					nm.traitPool = rangeFunc(nm.traitDictSize);
					nm.createModel();
					render(nm, false, showCites, showShares);
					d3.select("#avgTraitStat").text(function() {
							return "Avg. Num. Traits shared w/ Parents: "+nm.avgNumTraitShares();
					})
					return nm;
			}

			function updateNumGens(nm, newNG) {
					yScale.domain(rangeFunc(newNG))
					nm.clear();
					nm.numGens = newNG;
					nm.createModel();
					render(nm, false, showCites, showShares);
					d3.select("#avgTraitStat").text(function() {
							return "Avg. Num. Traits shared w/ Parents: "+nm.avgNumTraitShares();
					})
					return nm;
			}

			function updatePerGen(nm, newPG) {
					xScale.domain(rangeFunc(newPG))
					nm.clear();
					nm.entitiesPerGen = newPG;
					nm.createModel();
					render(nm, false, showCites, showShares);
					d3.select("#avgTraitStat").text(function() {
							return "Avg. Num. Traits shared w/ Parents: "+nm.avgNumTraitShares();
					})
					return nm;
			}

			function updateTraitFilter(nm, trait) {
					var filteredShares = filterSharesByTrait(nm.getShareArray(), [trait]);
					render(nm, filteredShares, showCites, showShares);
					return filteredShares;
			}

			// Interactivity
			d3.select("#ppe").on("mouseup", function() {
					d3.select("#ppe-value").text(this.value);
					updateParentsPer(nm, this.value);
			})

			d3.select("#tpe").on("mouseup", function() {
					d3.select("#tpe-value").text(this.value);
					updateTraitsPer(nm, this.value);
			})

			d3.select("#tds").on("mouseup", function() {
					d3.select("#tds-value").text(this.value);
					updateTraitDictSize(nm, this.value);
			})

			d3.select("#ng").on("mouseup", function() {
					d3.select("#ng-value").text(this.value);
					updateNumGens(nm, this.value);
			})
			
			d3.select("#pg").on("mouseup", function() {
					d3.select("#pg-value").text(this.value);
					updatePerGen(nm, this.value);
			})

			d3.select("#citeToggle").on("click", function() {
					showCites = !showCites;
					render(nm, false, showCites, showShares);
			});

			d3.select("#shareToggle").on("click", function() {
					showShares = !showShares;
					render(nm, false, showCites, showShares);
			});

			// make csv downloadable. 
			d3.select("#parCsvDownload").on("click", function() {
					var data = getParentageCSV(nm);
			                d3.select("#buttonz").select("#parCsvLink").remove();
					d3.select("#buttonz").append("a")
			                  .attr("id", "parCsvLink")
			                  .attr("class", "downloadLink")
					  .text("Download Parentage CSV")
					  .attr("href", data)
					  .attr("download", "parentage.csv");
			});

			d3.select("#trCsvDownload").on("click", function() {
			    var data = getTraitCSV(nm);
			    d3.select("#buttonz").select("#trCsvLink").remove();
			        d3.select("#buttonz").append("a")
			        .attr("id", "trCsvLink")
			        .attr("class", "downloadLink")
			        .text("Download Trait CSV")
			        .attr("href", data)
			        .attr("download", "traits.csv");
			})


			// generate tooltip based on entity. 
			function entityTip(ent) {
					var group = svg.append("g")
							.attr("class", "entityTip")
							.attr("transform", function() {
									return "translate(" + (xScale(ent.genIndex) + 20) + "," + (yScale(ent.generation) + 20) + ")";
							});



					var rect = group.append("rect")
					  .attr("class", "entityTipRect")
					  .attr("width", function() {
								return (50*(Math.min(6, ent.children.length) + 1)) + 60;
						})
					  .attr("height", 130)
					  .attr("rx", 10)
					  .attr("ry", 10);

					var titleText = group.append("text")
					  .attr("class", "tipTitleText")
					  .attr("x", 10)
					  .attr("y", 20)
					  .text(function() {
								return "Entity";
						});

					var genText = group.append("text")
					  .attr("class", "tipText")
					  .attr("x", 10)
					  .attr("y", 40)
					  .text(function() {
								return "generation: " + String(ent.generation);
						});

					var genIndText = group.append("text")
					  .attr("class", "tipText")
					  .attr("x", 10)
					  .attr("y", 55)
					  .text(function() {
								return "gen index: " + String(ent.genIndex);
						});


					var traitsText = group.append("text")
					  .attr("class", "tipText")
					  .attr("x", 10)
					  .attr("y", 75)
					  .text(function() {
								return "traits: " + String(ent.traits);
						});

					

					var parText = group.append("text")
					  .attr("class", "tipText")
					  .attr("x", 10)
					  .attr("y", 120)
					  .text(function() {
								if (ent.parents.length > 0) {
										var out = "parents: ";
										if (ent.parents.length > 5) {
												out += String(ent.parents.slice(0, 5)) + '...';
										} else {
												out += String(ent.parents);
										}
										return out;
								}
						});
					
					var childText = group.append("text")
					  .attr("class", "tipText")
					  .attr("x", 10)
					  .attr("y", 95)
					  .text(function() {
								if (ent.children.length > 0) {
										var out = "children: ";
										if (ent.children.length > 5) {
												out += String(ent.children.slice(0, 5)) + '...';
										} else {
												out += String(ent.children)
										}
										return out;
								}
						});
			}
			
			// generate tooltip based on entity. 
			function shareTip(shr) {
					var group = svg.append("g")
							.attr("class", "shareTip")
							.attr("transform", function() {
									return "translate(" + d3.mouse(this)[0] + "," + d3.mouse(this)[1] + ")";
							});

					var rect = group.append("rect")
					  .attr("class", "entityTipRect")
					  .attr("width", 120)
					  .attr("height", 110)
					  .attr("rx", 10)
					  .attr("ry", 10);

					var titleText = group.append("text")
					  .attr("class", "tipTitleText")
					  .attr("x", 10)
					  .attr("y", 20)
					  .text(function() {
								return "Trait Share";
						});

					var parentText = group.append("text")
					   .attr("class", "tipText")
					   .attr("x", 10)
					   .attr("y", 40)
					   .text(function() {
								 return "Parent: " + String(shr.share.parent);
						 })

					var childText = group.append("text")
					   .attr("class", "tipText")
					   .attr("x", 10)
					   .attr("y", 60)
					   .text(function() {
								 return "Child: " + String(shr.child);
						 })

					var traitText = group.append("text")
					  .attr("class", "tipText")
					  .attr("x", 12)
					  .attr("y", 80)
					  .attr("fill", function() {
								return colorScale(shr.share.trait);
						})
					  .text(function() {
								return "trait: " + shr.share.trait;
						});

			// Price Equation!
			var peqWidth = 300;

			var peqXscale = d3.scale.ordinal()
			    .domain([0,1])
			    .rangeRoundBands([0, peqWidth], 2);

			


			}

		</script>
		<div>
	</body>
</html>
